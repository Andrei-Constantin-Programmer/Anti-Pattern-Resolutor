{"_default": {"1": {"name": "Unsafe or Vague Exception Handling", "description": "Reliable exception handling, type safety, and controlled flow are essential forr writing maintainable and robust software. Unsafe or Vague exception handling often results in code that is fragile, difficult to test, and challenging to debug. Instead of providing meaningful error handling or clear separation of concerns, these implementations either hide the underlying problem or use language features in a way that breaks maintainability.", "category": "Uncategorised", "language": "Any", "severity": "MEDIUM", "problem": "Hidden failures : Catching exceptions without logging or meaningful handling hides the source of issues and makes debugging difficult\nPoor diagnosis : Broad exception handling with vague error messages hides intent and makes it harder to trace the root cause\nInconsistent runtime behaviour : using assertions for control logic can lead to unpredictable behaviour depending on the JVM configuration\nUncontrolled termination : Using system.exit() directly in application logic makes code untestable and prevents proper resource cleanup", "remediation": "Replace assertions with proper condition checks and informative exceptions to ensure consistent behaviour across environments\nAvoid silent catch blocks, log exceptions or rethrow them to preserve error context\nHandle specific exception types instead of catching broad categories like Exception or RuntimeException\nRefactor abrupt shutdown calls into controlled exits using exception handling or return code to support recovery", "limitation": "", "type": "antipattern", "source_file": "unsafe_or_vague_exception_handling.json"}, "2": {"name": "Deep Nesting", "description": "Deep Nesting occurs when conditional or loop blocks are embedded within one another across multiple levels, creating code with high indentation and complex control flow. While not always increasing cyclomatic complexity linearly, deep nesting significantly raises cognitive complexity (the mental effort required to understand, modify, and debug a method).", "category": "Uncategorised", "language": "Any", "severity": "MEDIUM", "problem": "Low readability : The \"arrowhead\" structure makes it hard to trace logic and understand the intended flow.\nHigh cognitive load : Developers must mentally track the conditions that lead to or prevent reaching a particular line of code.\nError-prone maintenance : Adding or modifying logic inside deeply nested blocks increases the risk of missing cases or introducing bugs.\nInhibited reuse and testing : Deep nesting often combines concerns that should be split into smaller, testable methods or units.\nPoor diffs in version control : Even small changes can alter indentation across many lines, making reviews harder.", "remediation": "Guard clauses (early return) : Exit early when preconditions fail, flattening the control flow\nExtract method : Isolate deeply nested blocks into private methods with clear names to separate concerns and reduce depth.\nInvet conditionals : Invert logic to return early or skip unnecessary branches.\nReplace nested loops with streams (Java-specific): Abstract common filtering or mapping logic into declarative operations.\nUse pattern matching : Replace layered `if` chains with clearer structural or type-based matching.\nEncapsulate state checks : Group multiple conditionals into intention-revealing boolean helpers or state objects.", "limitation": "Can conflict with existing code style : Teams unfamiliar with guard clauses may resist early exits or multiple returns.\nRefactoring can obscure logic during transition : Extracted methods must be clearly named to preserve readability and avoid confusion.\nNested logic may be unavoidable in rare edge cases : Complex parsing, state machines, or embedded domain-specific languages may naturally involve deeper control structures.", "type": "antipattern", "source_file": "deep_nesting.json"}, "3": {"name": "SRP Violation", "description": "The Single Responsibility Principle (SRP) is one of the SOLID principles of object-oriented design, stating that a class (or, at a lower level, a method) should have only one reason to change (i.e., it should have only one responsibility or concern). A SRP Violation occurs when a class (method) takes on multiple unrelated responsibilities, making it harder to maintain, test, and understand. These violations often result in bloated classes or methods that mix unrelated concerns such as I/O, business logic, error handling, and configuration.", "category": "Uncategorised", "language": "Any", "severity": "MEDIUM", "problem": "Poor maintainability : Changing one responsibility might inadvertently affect others, introducing bugs.\nLow cohesion : Code with unrelated responsibilities lacks a clear purpose, reducing clarity and reusability.\nDifficult testing : Unit testing becomes more complex as setup may require mocking or initializing unrelated dependencies.\nCode duplication and tight coupling : Responsibilities are harder to reuse or share, often leading to repeated logic or tight inter-class dependencies.\nHarder onboarding : New developers struggle to understand the purpose and scope of large, multi-purpose classes.", "remediation": "Extract Method \\- Split complex methods into smaller, single-purpose private methods.\nEarly Return (Guard Clauses) \\- Use early exits to reduce nested logic and clarify separate responsibilities.\nUse Local Functions/Lambdas \\- Encapsulate small inline logic into local functions for clarity.\nEncapsulate Temporary Variables \\- Move logic-heavy expressions into descriptive helper methods.\nGroup Related Logic \\- Cluster related operations into distinct helper methods within the same class.\nSeparate Concerns in Loops \\- Extract filtering, transforming, and aggregating into distinct steps.\nIsolate Logging/Error Handling \\- Move side-effect code like logging into dedicated private methods (unless the logging is a trivial single line and does not obscure business logic).", "limitation": "Fixing certain SRP violations (especially class-level violations) requires changing public method signatures, creating new classes, and/or breaking interfaces.\nMethods often depend on multiple injected services or shared state; untangling responsibilities might require broader architectural changes.\nLogging, error handling, metrics, and security checks are often scattered across responsibilities and difficult to isolate cleanly at the method level without aspect-oriented programming (AOP) or middleware/interceptor patterns.", "type": "antipattern", "source_file": "srp_violation.json"}, "4": {"name": "Magic Constants", "description": "Magic constants (or magic numbers) are hard-coded literal values (e.g., 3.14, 42, \"admin\") that appear directly in code without context or explanation. These values become problematic when their purpose is unclear, undocumented, or reused inconsistently. While some literals (like 0, 1, or -1) may be self-explanatory in some contexts, others represent thresholds, identifiers, or rules that should be named and documented for clarity.", "category": "Uncategorised", "language": "Any", "severity": "MEDIUM", "problem": "Poor readability : Developers must guess the meaning of the value, increasing cognitive load.\nLow maintainability : Changing the value requires updating it everywhere, risking inconsistent updates.\nHarder debugging : Literal values lack descriptive meaning in stack traces, logs, or debuggers.\nDuplication : The same literal used in multiple places leads to repeated logic and tighter coupling.\nViolation of DRY : Embeds implicit meaning multiple times without abstraction.", "remediation": "Define Constants - Move literal values into named constants (e.g., const, final, or static readonly).\nUse Enums - Group related constants (e.g., roles, statuses) as enumerations with meaningful names.", "limitation": "Extracting trivial values like 0 or 1 may clutter code and reduce clarity if overdone.\nIn performance-critical code, indirection through constants or functions may introduce slight overhead.\nOver-abstracting unnamed constants (e.g., MAXCOUNT3) may make code harder to understand.\nIf a value is used only once and is self-explanatory, extracting it may be unnecessary overhead.", "type": "antipattern", "source_file": "magic_constants.json"}, "5": {"name": "Generic Exception handling", "description": "Generic exception handling refers to the use of broad or unspecific catch blocks (catching but ignoring the exceptions). These patterns obscure the true source of errors, suppress the useful debugging information and can unintentionally hide critical failures. This anti-pattern often stems from the desire to keep the code running, but typically leads to weak systems and increased technical debt.", "category": "Uncategorised", "language": "Any", "severity": "MEDIUM", "problem": "Loss of context : Catching high-level exceptions removes the granularity needed to understand specific failure reasons\nRepeated boilerplate : Developers may re-implement logging, default values, or stream-closing logic instead of using safe utility methods\nViolation of fail-fast principles : Silent or overly generic handling can let critical errors go unnoticed for too long", "remediation": "", "limitation": "Catching too many specific exceptions can bloat the code and reduce readability.\nRefactoring exception handling may require thorough testing to avoid regressions.\nOver-logging exceptions can clutter logs and obscure real issues.\nSecurity-sensitive applications may need specialised exception handling strategies to avoid leaks", "type": "antipattern", "source_file": "generic_exception_handling.json"}}}